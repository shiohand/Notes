# ブランチ

- [ブランチ](#ブランチ)
  - [ブランチの運用モデル](#ブランチの運用モデル)
    - [メインブランチ](#メインブランチ)
    - [featureブランチ(トピックブランチ)](#featureブランチトピックブランチ)
    - [releaseブランチ](#releaseブランチ)
    - [hotfixブランチ](#hotfixブランチ)
  - [HEADからの相対指定](#headからの相対指定)
- [ブランチの操作](#ブランチの操作)
  - [ブランチの作成 ブランチの移動](#ブランチの作成-ブランチの移動)
    - [作成](#作成)
    - [移動](#移動)
    - [作成と移動](#作成と移動)
  - [HEAD](#head)
  - [marge](#marge)
    - [競合](#競合)
    - [マージのパターン](#マージのパターン)
  - [rebase](#rebase)
  - [cherry-pick コミットを抜き取る](#cherry-pick-コミットを抜き取る)
  - [squash](#squash)
  - [stash](#stash)

## ブランチ

* 機能追加、リリース版、バグ修正などの履歴が全て同じ場所にあると分かりにくく、競合も頻繁に起こるので使い勝手が悪くなる
* リリース版の履歴やバグ修正の履歴などに枝分かれさせ、別のリポジトリのように並行して変更を行う

一人ひとりは、変更したいブランチの内容をワークツリーに展開する

* リモート側
  * リモートブランチ(master, develop...)
* ローカル側
  * リモート追跡ブランチ(origin/master, origin/develop...)
  * ローカルブランチ(master, develop...)

※リモート追跡ブランチ

* fetchしたブランチを持ってきたり
* HEADはFETCH_HEADとなる
* `git merge` でローカルブランチにマージ
* `git diff FETCH_HEAD..HEAD` で差分チェック可能

### ブランチの運用モデル

A saccessful Git branching model

ブランチを以下の4種類に分ける
* メインブランチ
* フィーチャーブランチ(トピックブランチ)
* リリースブランチ
* ホットフィックスブランチ

#### メインブランチ

リリース用と開発用のブランチ

* masterブランチ
\- リリース可能な状態だけを管理
\- コミットにはタグを使用し、リリース番号を記録
* developブランチ
\- 普段の開発で使用するブランチの統合ブランチ

#### featureブランチ(トピックブランチ)

developブランチから分岐する
個々の作業となるため、リモートでは管理せず、完了したらdevelopにマージ

#### releaseブランチ

リリースの準備を行うブランチ
ブランチ名は `release-Xxxx` が慣例

developブランチがリリース可能な状態になってきたときに作成
最終的なバグ修正などを行う

修正後はmasterブランチにマージし、マージコミットにはリリース番号のタグを付与
同時にdevelopブランチにも反映させたいのでマージ

#### hotfixブランチ

リリース後に緊急の修正が必要になった場合に作成する
ブランチ名は `hotfix-Xxxx` が慣例

developブランチは通常の開発を行っているので使えない
修正後はリリースブランチのときと同様にマージ

### HEADからの相対指定

| 記述 | 遡る世代数 |
| ---- | ---------- |
| ~1   | 1世代前    |
| ~2   | 2世代前    |

マージ前の複数あるブランチの選択
| 記述 | 遡る世代数                           |
| ---- | ------------------------------------ |
| ~1^1 | 1世代前のマージの前の1つ目のブランチ |
| ~1^2 | 1世代前のマージの前の2つ目のブランチ |


## ブランチの操作

### ブランチの作成 ブランチの移動

#### 作成

`$ git branch issue1`

#### 移動

`$ git checkout issue1`

#### 作成と移動

`$ git git checkout -b issue1`

移動先の最後のコミットの内容をワークツリーに展開する
展開後、コミットは移動先ブランチに対して追加されるようになる

### HEAD

現在のブランチの頭、現在のコミット(デフォルトはmasterブランチの先頭)

### marge

変更履歴は分岐先ブランチに残したまま統合
現在のブランチにほかのブランチをマージする

#### 競合

* 最後のpullから次のpushのあいだに、他の人のpushがあった場合、pushが競合
* 競合した場合、上書きされることを避けるために後のpushは拒否される
* 他のpushによる変更を取り込んでからpush

競合とかえぐいときは一旦マージ前からやりなおすのもあり

#### マージのパターン

* fast-forward(早送り)マージ
\- 一方にコミットがある場合
\- ない方がある方に追いつくだけなので、マージのコミットは作られない
\- (オプションでnon-fast-forwardマージにするとマージのコミットを作る)

* オートマージ
\- どちらにもそれぞれのコミットがあり、競合していない場合
\- マージのコミットを作ってそこで合流

* 競合(コンフリクト)の解消
\- ファイルの同じ行に違う変更が加えられている競合状態
\- gitからファイル内の競合部分を提示されるため、それらを修正してからコミット
\- ファイルを直接編集して保存すればよい
\- 現在のブランチはmasterブランチに統合される

### rebase

変更履歴を統合先ブランチの先頭に追加して統合
履歴は単純になるが、場合によってはコミットが不変になるらしい

トピックブランチで作業中、masterにバグ修正が追加されたので修正後のコミットにrebaseとからしいがわからん

`rebase -i [id]`
* コミットの書き換え、入れ替え、削除、統合
\- コミットIDから古い順にコミットが表示される
\- コミットの行を消すとコミットの取り消し
\- 先頭のpickをほかのものに置き換えるとコミットメッセージなどの編集

push前の整理によいみたい

* pick->squash
\- 意味の同じコミットをまとめる
\- コミットメッセージを付けてコミットを合体
* pick->edit
\- コミットを修正
\- コミットがチェックアウトされた状態になり、該当のファイルを修正

* `rebase --abort`
\- rebase作業キャンセル
* `commit --amend`
\- 変更を保存(競合したら修正)
  * `rebase --continue`
  \- rebaseを実行

コミット漏れしていたファイルを追加
など
(rebaseしたあとORIG_HEADにresetしなおして戻るとかいうのもできるらしい)

### cherry-pick コミットを抜き取る

* `cherry-pick [id]`
\- 別のブランチのコミットを現在のブランチにコピー

別ブランチから指定したコミットをコピーして取り込む
競合が発生したら修正

コミットを別のブランチに移動、または複製する

### squash

マージするブランチをひとつに統合したコミットでマージ
バグ修正のブランチとか、まとめちゃっていいやってやつに使う？

`merge --squash [branch]`

競合は修正してコミット

### stash

変更内容の一時的な退避

まだコミットしていない変更がある状態でチェックアウトすると、その変更内容は移動先ブランチに対するものになる
変更したファイルが移動先ブランチで競合する場合はチェックアウトに失敗する

コミットされていない変更を一時的に退避
退避しておくことでチェックアウトが可能になる
後から退避させた変更を取出し、元のブランチに反映させるなり別のブランチに反映させるなりする。
