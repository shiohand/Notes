# memo


## 情報の基礎理論

### 基数変換

10 -> 2 の筆算のやつは、上が小数点がわ。

```
5.625 -> 101.101

5....   | ..625
2...1   | 1.25
1...0   | 0.5
0...1   | 1.0
-> 101. | -> .101

6.375 -> 110.011

6.... | ..375
3...0 | 0.75
1...1 | 1.5
0...1 | 1.0

```

## データ構造とアルゴリズム

### 補数

2の補数
補数にするときも戻すときも
ビット反転 -> +1
(-1 -> ビット反転 でも同じだけどそうするメリットは別に)

2の補数あるある
全部1 = -1
最上位1 = -2^n
最上位1とその他 = -2^n + その他部分そのまま読み (1011 -> -8 + 3 -> -5)
-xを作るとき、最上位1とその他に2n-xそのまま書き (-5 -> 8 - 5 = 3 -> 1011)

### 浮動小数点数表現

| 符 | 指(2の補数あり) | 仮(絶対値) |

32bitの例
| 1bit | 7bit | 24bit |

(むりやり10進数で例えるなら)
7.25 = 0.725 * 10^(1)
| \+ | 0000001 | 72500000... |

(2進数)
111.01 = 0.11101 * 2^(3)
| \+ | 0000011 | 11101000... |

0.0011101 = 0.11101 * 2^(-2)
| \+ | 1111110 | 11101000... |

* IEEE751の形式例とバイアス値
\- 指数部に2の補数入るのがめんどくせえんよ
\- 天才なので -128から127 じゃなくて 0から255にするんよ
\- だから指数部は 8bit 使うし、内容は 実際の指数+127 を入れるんよ
\- 仮数部が1bit分減るのは、正規化を1.Mにすることでやりくりできるんよ
\- 上ので0.Mだったのはわかりやすさかな？

0.0011101 = 1.1101 * 2^(-3)
-3 + 127 = 124
| \+ | 01111100 | 1101000... |

### 誤差

| 誤差         | いめーじ                                                      |
| ------------ | ------------------------------------------------------------- |
| 桁あふれ誤差 | オーバーフローは最上階より高い アンダーフローは最地下より低い |
| 丸め誤差     | 切り捨て切り上げ四捨五入                                      |
| 桁落ち       | 差ちっさすぎてメモリがたらん                                  |
| 情報落ち     | 比べる人同士の身長差がえぐくて一度に視界に入れきらん          |
| 打切り誤差   | 「3、てん、1、4、1、5……あとはいいや」                         |

### シフト演算

論理シフト ふつう
算術シフト 符号つき

### 計測・制御

PCM方式(パルス符号変調方式)
標本化->量子化->符号化

A/Dコンバータ
センサ
アクチュエータ
アンプ

PWM制御(Pulse Width Moduration)
パルス幅変調制御。オンの長さで強さ変える

### 行列

正方行列 せいほうな
単位行列 Eってかく 何に単位行列をかけても単位行列のまま 何に1をかけても1的な

A*Bが単位行列のとき、Aは正則行列・Bは逆行列となる
逆行列は A^(-1) で表す
A * A^(-1) = E
n * n^(-1) = 1的な
行列では A\*B=B\*A とはならないので注意

たしひき -> まんま
かけざん -> スカラー倍(全部にかける) 行列同士(eww)

各成分をこうみて
11 12 13
21 22 23

1(A1行)1(B1列) 1(A1行)2(B2列)...
2(A2行)1(B1列)...
って感じ

### 論理演算

not(A * B) = notA + notB
not(A + B) = notA * notB
A * (B + C) = (A * B) + (A + C)
A + (B * C) = (A + B) * (A + C)

排他的論理和 = (notA * B) + (A * notB) 丸暗記。論理回路も覚えちゃえ。

### アルゴリズム

#### ソート

* 基本交換法 隣接交換法 バブルソート
* 基本選択法 選択ソート
* 基本挿入法 挿入ソート

比較回数 N(N-1) / 2

* 改良挿入法 シェルソート
* クイックソート
* ヒープソート

#### サーチ

* 線形探索法 逐次探索法 リニアサーチ
\- 探索回数 (N + 1) / 2
* 二部探索法 バイナリサーチ
\- 探索回数 log2N
* ハッシュ探索法
\- 探索回数 1

log2Nは、値がNに近くなる2の乗数
N ≒ 2^log2N

ハッシュ探索法はアドレスの衝突(シノニム)の可能性あり

## システムの構成と方式

* 3層クライアントサーバシステム
\- プレゼンテーション層(クライアント) ファンクション層(サーバ) データベース層(サーバ)

* シンクライアントシステム
\- アプリケーションをサーバ上で動かす TCO(total cost of ownership)削減

仮想サーバ
* スケールアップ(メモリ増)
* スケールアウト(台数増)

組込みシステム
* ワンチップマイコン
\- マイコン
* SoC(System on Chip)
\- 専用チップ
* エッジコンピューティング
\- サーバを物理的に近くに置く


高性能化
* デュプレックスシステム
\- システムのCPU切替可能
* デュアルシステム
\- システムのハードごと二つでリアルタイムダブルチェックって感じ的な
* 密結合マルチプロセッサ
\- CPUのみ二つ 小回りがきく
* 疎結合マルチプロセッサ
\- OSとメモリも二つ ジョブやトランザクション単位の分担に強い
* クラスタシステム
  * HAクラスタ
    * 負荷分散クラスタ 並列稼働、分担
    * フェイルオーバークラスタ 予備稼働、保険
  * HPCクラスタ High Performance Conputing 連携、強化

| RAID | memo           |
| ---- | -------------- |
| 0    | ストライピング |
| 1    | ミラーリング   |
| 3    | 1台ぱりてぃ    |
| 5    | 分散ぱりてぃ   |

### 性能評価
MIPS 命令実行回数(百万) / 秒
FLOPS 浮動小数点演算の回数 / 秒
ベンチマーク SPECint, SPECfp, TPCベンチマークテスト(トランザクション処理のシステム)

* 命令ミックス
\- テスト用てんぷれせっと的な
* ギブソンミックス 科学
\- コマーシャルミックス 商業

## システム開発技術と監査

CIO
情報システム戦略
経産省の システム管理基準 で規範が定められる

全体最適化計画 -> 開発計画

### SLCP (Software Life Cycle Process)

共通フレーム SLCP-JCF

プロセス
企画 -> 要件定義 -> システム開発 -> ソフトウェア実装 -> 保守
実装後のプロセス
運用 -> サービスマネジメント

* システム化構想の立案
* システム化計画
* 要件定義
\- 業務要件定義, 機能要件定義, 非機能要件定義)
* 調達
\- RFI : Request For Information
\- RFP : Request For Proposal

###  EA (Enterprise Architecture)

業務とシステムの最適化手法 As-Isモデル, To-Beモデル

* ビジネスアーキテクチャ
\- 業務プロセスや情報の流れ
\- 業う説明書, 機能構成図(DMM), 機能情報関連図(DFD), 業務フロー図
* アプリケーションアーキテクチャ
\- 業務支援のシステム
\- 情報システム関連図, 情報システム機能構成図
* データアーキテクチャ
\- データや構造
\- 情報体型整理図(クラス図), 実態関連ダイアグラム(ERD), データ定義表
* テクノロジアーキテクチャ
\- 技術的構成要素
\- ネットワーク構成図, ソフトウェア構成図, ハードウェア構成図

#### DFD (Data Flow Diagram)

#### E-R図 (Entity-Relationship Diagram)

#### UML (Unified Modeling Language)

* オブジェクト図
* クラス図
* ユースケース図
\- 使利用者とシステムのやり取り 用例
* シーケンス図
\- オブジェクト間のメッセージの流れの時系列
* コミュニケーション図
\- メッセージのやりとりの接続関係
* アクティビティ図
\- 制御の流れ

### システム開発

#### 設計

| 段階                                 | 対応するテスト                           |
| ------------------------------------ | ---------------------------------------- |
| システム要件定義(基本計画)           | システム適格性確認テスト(システムテスト) |
| システム方式設計(外部設計)           | システム結合テスト                       |
| ソフトウェア要件定義(外部設計)       | ソフトウェア適格性確認テスト             |
| ソフトウェア方式設計(内部設計)       | ソフトウェア結合テスト(結合テスト)       |
| ソフトウェア詳細設計(プログラム設計) | ソフトウェアユニットテスト(単体テスト)   |
| プログラミング                       | -                                        |

* 外部設計 論理的な設計、規約、コード設計
  * サブシステムへの分割
  * ヒューマンインターフェースの設計
  * コード設計
  * 論理データ設計
* 内部設計 外部設計を元に具体的な開発 コード実現
  * 機能分割・構造化
  * 物理データ設計
  * 入出力詳細設計

#### モジュール分割

1. 最上位のモジュール定義
2. 機能分析
3. 分割技法選択
4. 分割
5. インターフェースの定義
6. 他に分割できるとこ探し

データの流れに注目する STS分割法, トランザクション分割法, 共通機能分割法
データ構造に注目する ジャクソン法(入出力データの構造から), ワーニエ法(扱うデータの構造から)

##### モジュール強度

ビジネスライクに群れよう

1. 機能 単一機能
2. 情報 単一クラスの複数機能
3. 連絡 手順+モジュール内でデータを共有したり機能を呼び出し合ったり
4. 手順 まとめて実行する一連の機能をまとめたけどデータ構造的には虚無
5. 時間 なんかこいつら使うタイミング一緒だよねってやつ
6. 論理 引数で呼び出す機能を変える感じのまとまり
7. 暗号 関係ない

##### モジュール結合度

シンプルなデータじゃないと場所や相手が変わったとき面倒になりやすい

1. データ データ
2. スタンプ 構造ありデータ
3. 制御 引数で動作を指示
4. 外部 グローバル領域のデータ
5. 共通 グローバル領域のデータ構造
6. 内容 他モジュールの内容(変数とか)や命令そのもの

#### テスト

信頼度成長曲線(ゴンベルツ曲線)

##### ソフトウェアの品質特性

* 機能性
* 脂溶性
* 信頼性 稼働率、回復
* 効率性 性能
* 保守性
* 移植性

##### ユニットテスト

| 網羅           | 詳細                |
| -------------- | ------------------- |
| 命令           | 条件文 真           |
| 分岐(判定条件) | 条件文 真偽         |
| 条件           | 条件式 真偽重複可能 |
| 複数条件       | 条件式 真偽総当り   |

##### ソフトウェア結合テスト

ドライバ(driver : 運転手)
スタブ(stub : 切り株)

##### システム結合テスト

| テスト   | 詳細                                           |
| -------- | ---------------------------------------------- |
| 機能     | 機能                                           |
| 性能     | 処理能力や応答時間                             |
| 例外処理 | 例外処理                                       |
| 負荷     | 量的な負荷                                     |
| 操作性   | 使いやすさ、わかりやすさ                       |
| 状態遷移 | イベントと内部状態の設計どおりにシステムが動作 |

##### 導入

運用テスト 受け入れテスト

##### 保守

リグレッションテスト(退行テスト)
リファクタリング

#### レビュー

ラウンドロビン
ウォークスｒーウ
インスペクション (議長のモデレータを固定)

### ITサービスマネジメント

ITIL (Information Technology Infrastructure Library)

サービスデスク
インシデント管理
問題管理
サービス資産管理及び構成管理
変更管理
リリース管理及び展開管理

サービス要求 インシデントじゃない普通の問い合わせ
JIS Q 20000(ITILに基づいた認証基準)では、インシデント管理及びサービス要求管理

ITサービスデザイン
SLA, SLM

* 可用性管理
* キャパシティ管理
* ITサービス継続性管理
\- 災害時とかの用意、復旧
* ITサービス財務管理
\- コスト予測と実際

ファシリティマネジメント

### プロジェクト管理

PMBOK (Project Management Body of Knowledge)
* 統合 プロジェクト憲章作成 構成管理(バージョン管理とか)
* スコープ WBS
* タイム
* コスト
  * ファンクションポイント法 帳票数や画面数他
  * プログラムステップ法(LOC : Line of Code)
  * 類推見積法
  * 標準タスク法 WBSに基づく
  * COCOMO法(COnstructive COst MOdel) 行数と補正係数
* 品質
* 人的資源
* コミュニケーション
* リスク
* 調達

プロセス
1. 立ち上げ
2. 計画
3. 実行
4. 監視コントロール
5. 集結

ファージビリティスタディ 実行可能性調査

## ネットワーク技術

## データベース技術

## 情報セキュリティ

## 情報化と経営

