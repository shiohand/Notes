<!DOCTYPE html>
<html lang="jp">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
  <title>jQuery</title>
</head>
<body>

  <h1>jQuery基礎</h1>

  <h2>ready</h2>
  <script>
    "1. jQuery関数を利用。万一にも衝突無し";
    jQuery(function($) {
      // 処理;
    });

    "2. documentのreadyメソッドを利用"
    $(document).ready(function($) {
      // 処理;
    });

    "3. 2の省略形 最もメジャーな気がする"
    $(function($) {
      // 処理;
    });
  </script>

  <h2>基本</h2>
  <script>
    "readyとして";
    "$(関数)";
    $(function($) {
      // 処理;
    });

    "jQueryオブジェクト";
    '$("セレクタ―")';
    let $変数 = $(".btn .primary");

    "jQueryオブジェクト";
    "$(DOM要素)";
    // this
    let $ths = $(this);
    // windowとdocumentも可能
    let $win = $(window);
    let $doc = $(document);
    // 要素を生成(後述)
    let $li = $("<li>あいてむ</li>");
  </script>

  <h2>要素の生成</h2>
  <script>
    "要素を生成";
    '$("HTML文字列")';
    $("<a></a>"); // "<a>"のみでも動くが非推奨
    $("<img>");
    $('<li class="item">アイテム</li>');

    "要素を生成 オブジェクトとしてattributesを追加"
    '$("HTMLタグのみ", { attribute })';
    $("<a></a>", {        // ここで属性(href=""など)を含めてはいけない
      href: "abc.html",
      target: "_blank",
      "class": "myClass"  // 予約語のためStringで
    });

    "jQueryメソッドも指定可能(Ver.1.8から)";
    "キーにメソッド名、バリューに引数";
    "ただし読みにくいのでやらない";
    $("<div></div>", {
      css: {
        border: "5px solid gray",
        backGroundColor: "ashgray"
      },
      addClass: "my-div",
      on: {
        click: function(event) {
          // 処理;
        }
      }
    });
  </script>

  <h2>jQueryオブジェクトの利用</h2>

  基本的に戻り値はjQueryオブジェクトなので、メソッドチェーン可能
  (取得系メソッドやその他の戻り値が必要なメソッド以外)
  <script>
    // 要素の取得とメソッド実行
    let $color_div = $("#color_div");
    $color_div.css("border", "1px solid red");
    $color_div.css("display", "block");
    // メソッドチェーン
    $("#color_div").css("border", "1px solid red").css("display", "block");
  </script>

  複数要素を取得している場合
  メソッドによる要素への変更は全ての要素に与えられる(foreach的な)
  値を取得するメソッドは一つ目の要素のものを取得
  <script>
    let $lis = $(".items li");
    $lis.css("color", "red"); // すべてに適用
    $lis.css("color");        // 先頭の一つの値を取得
  </script>

  <h2>セレクタ―</h2>
  は、飛ばしまして

  <h2>jQuery独自のセレクタ―</h2>
  要素数のカウントは 0 始まりになるので注意(CSSは 1 始まり)

  独自？か調べる
  :contains(text)  テキストコンテントを判定
  :has(slct)
  :empty           子ノードを持たない
  :parent          子ノードを持つ

  <h3>子要素フィルター インデックス</h3>
  :first
  :last
  :even      偶数インデックス -> 直感的には奇数番目
  :odd       奇数インデックス -> 直感的には偶数番目
  :eq()      インデックス
  :gt()      より大きい
  :lt()      未満
  :header    headingタグ要素
  :animated  アニメーション動作中要素

  <!-- ややこしいところ -->
  <ul> <li>1</li><li>2</li><li>3</li> </ul>
  <ul> <li>4</li><li>5</li><li>6</li> </ul>
  <ul> <h1>7</h1><li>8</li><li>9</li> </ul>
  li                   -> 1, 2, 3, 4, 5, 6, 8, 9
  li:first             -> 1           一つ目のli
  li:first-child       -> 1, 4        子要素の一つ目であるli
  li:even              -> 1, 3, 5, 8, 9
  li:nth-child(even)   -> 2, 5, 8     子要素の(even)番目であるli
  li:nth-of-type(even) -> 2, 5, 9     子要素のliの(even)番目であるli
  li:eq(2)             -> 3
  li:gt(2)             -> 4, 5, 6, 8, 9
  li:lt(2)             -> 1, 2

  <h3>子要素フィルター フォームタイプ</h3>
  jQuery独自？非推奨？右の書き換えが良い？
  :button    button, input[type="button"]
  :checkbox  [type="checkbox"]
  :file      [type="file"]
  :image     [type="image"]
  :input     input, textarea, select, button
  :password  [type="password"]
  :radio     [type="radio"]
  :reset     [type="reset"]
  :submit    [type="submit"]
    buttonのsubmitを含むかはブラウザ差あり
  :text      [type="text"]

  jQuery独自？"input"とかを省略できるってことか 非推奨じゃない？
  :checked   input:checked
  :selected  select option:selected
  :disabled  input:disabled
  :enabled   input:enabled
  :visible   visibirity:hidden, opacity:0などの透明はvisible
  :hidden    display:none, type="hidden" widthとheightが0 親から非表示

  <h3>フィルター メソッド</h3>
  is(slct)  一致すればtrue、でなければfalse
  <script>
    // 指定した要素がcheck
    let ret1 = $("div").is(".man");
    let ret2 = $("#chk").is(":checked");
  </script>

  <h3>attribute操作</h3>
  取得
    attr(attr)        val
  代入
    attr(attr, val)
    attr({attr: val, attr: val...})
    attr(attr, function(idx, attr) { /* 代入する値 */ })
    <script>
      $('img').attr("title", function(idx, val) {
        // [(インデックス)] (現在のval) (altのval) にしたい
        return "[" + index + "]" + val + this.alt;
      });
    </script>
  削除
    removeAttr(attr)  val

  <h3>class操作</h3>
  addClass(cls)
  removeClass()          クリア
  removeClass(cls)       指定のクラスのみ
  toggleClass(cls)
  toggleClass(cls, bool) trueなら追加、falseなら削除
  hasClass(name)

  <h3>css操作</h3><!-- 単位とかwidth()たちとの違いとかぐぐりなおす -->
  取得
    単位はpx, 戻り値は単位含む文字列
    propは文字列としてクォーテーションをつけるかキャメルケースで書くか
  代入
    相対値("+=15"など)あり
  css(prop)              取得
  css(prop, val)         "+=15"などで値の変更可能(px？)
  css({prop: val, prop: val...})

  <h3>width, height操作</h3>
  取得
    戻り値は整数値と一部小数値, box-sizingの影響なし
  代入
    単位付きの文字列("50%"など)可能, box-sizingの影響あり

  width()
  height()
  innerWidth()
  innerHeight()
  outerWidth(bool = false)   trueでmarginを含む
  outerHeight(bool = false)  trueでmarginを含む

  width(val)
  height(val)
  innerWidth(val)
  innerHeight(val)
  outerWidth(val)
  outerHeight(val)

  <h3>scroll, 座標操作</h3>
  scrollTop()   スクロールバーが表示されない場合は0
  scrollLeft()  横
  offset()      htmlに対する位置 戻り値はオブジェクト
  position()    位置的な親要素(position: static以外である親)に対する位置
  <script>
    let off = $("#main").offset(); // { top=50, left=20 }
    $("#main").offset().top; // 50
    off.left; // 20
  </script>

  <h2>html, text, form</h2>

  <h3>html(), text()</h3>
  html()  HTML文字列 HTML文字列の代入はHTMLとして反映
  text()  テキストノードのみ HTML文字列の代入はエスケープされてただの文字列に
    ※複数あるときはすべての要素のテキスト部分をつなげて取得する 子孫要素があっても同様か？
  だいたいinnerHTML()とinnerText()的な違い

  <!-- html()とtext()の取得 -->
  <ul>
    <li><span>太郎</span></li>
    <li><span>次郎</span></li>
    <li><span>花子</span></li>
  </ul>
  <script>
    let ret1 = $("li").html(); // <span>太郎</span>
    let ret2 = $("li").text(); // 太郎次郎花子
  </script>

  <h3>form, val()</h3>
  val()  フォーム要素の値 multipleでは配列で返す

  <!-- selectの例 -->
  <script>
    // name=rdoのラジオボタンでチェックされているもの
    let checked = $("input[type=radio][name=rdo]:checked").val();
    // セレクトボックスは親のselectのval()でよい
    let selected = $("select").val();
    // チェックボックスはcheckedが複数とれると、そのままval()しても一つ目しか取得できない
    let checkeds = $("input[type=checkbox][name=chk]:checked").map(function() {
      return $(this).val();
    }).toArray;
  </script>

  val(value)
    入力要素の場合は入力値の変更
    選択要素の場合は選択状態に
    複数選択するにはval(arr)で複数指定

  <h2>要素の追加等</h2>
    要素の追加
    要素がドキュメント内にある場合は移動
    追加される対象が複数の場合は全てに追加(複製)
  追加される親のメソッド(target.append(elm))
    append(elm)   親の末尾
    prepend(elm)  親の先頭
    before(elm)   親の前
    after(elm)    親の後ろ
  追加する子のメソッド(elm.appendTo(target))
    appendTo(elm)
    prependTo(elm)
    insertBefore(elm)
    insertAfter(elm)

  <!-- 例 -->
  操作前
  <ul>
    <li id="taro">太郎</li>
    <li>次郎</li>
    <li>三郎</li>
  </ul>
  <ul>
    <li>花子</li>
  </ul>

  <script>
    $("ul").append($("#taro"));
  </script>

  操作後
  <ul>
    <li>次郎</li>
    <li>三郎</li>
    <li id="taro">太郎</li>
  </ul>
  <ul>
    <li>花子</li>
    <li id="taro">太郎</li>
  </ul>

  <h2>wrap, replace</h2>
  wrap()         対象をタグでラップ
  wrapAll()      対象をまとめてラップ 対象以外は押し出される
  wrapInner()    指定要素の中身をラップ
  unwrap()       指定要素の中身のみ残す wrapAllの逆的な

  replaceWith()  要素を指定の要素で置き換え 戻り値が置き換えられた要素
  replaceAll()   append()とappendTo()的な
    A.replaceWith(B) と B.replaceAll(A) が同じ

  <!-- 例 -->
  操作前
  <span>太郎</span>
  <span>次郎</span>

  <!-- 例 wrap() -->
  <script>
    $("span").wrap("<div></div>");
  </script>
  操作後
  <div><span>太郎</span></div>
  <div><span>次郎</span></div>

  <!-- 例 wrapAll() -->
  <script>
    $("span").wrapAll("<div></div>");
  </script>
  操作後
  <div>
    <span>太郎</span>
    <span>次郎</span>
  </div>

  <!-- 例 wrapAll()-2 -->
  操作前
  <span>太郎</span>
  <strong>花子</strong>
  <span>次郎</span>

  <script>
    $("span").wrapAll("<div></div>");
  </script>

  操作後 追い出される
  <div>
    <span>太郎</span>
    <span>次郎</span>
  </div>
  <strong>花子</strong>

  <!-- 例 wrapInner() -->
  <script>
    $("span").wrapInner("<div></div>");
  </script>

  操作後
  <span><div>太郎</div></span>
  <span><div>次郎</div></span>

  <!-- 例 unwrap() -->
  操作前
  <div><span>太郎</span></div>
  <div><span>次郎</span></div>
  <div>
    <span>三郎</span>
    <span>四郎</span>
  </div>

  <script>
    $("span").unwrap();
  </script>

  操作後
  <span>太郎</span>
  <span>次郎</span>
  <span>三郎</span>
  <span>四郎</span>

  <!-- 例 replaceWith() -->
  操作前
  <div class="container">
    <div class="inner first">太郎</div>
    <div class="inner second">次郎</div>
    <div class="inner third">三郎</div>
  </div>

  <!-- 例 replaceWith()-1 -->
  <script>
    $("div.second").replaceWith("<h2>花子</h2>");
  </script>

  操作後
  <div class="container">
    <div class="inner first">太郎</div>
    <h2>花子</h2>
    <div class="inner third">三郎</div>
  </div>
  
  <!-- 例 replaceWith()-2 -->
  <script>
    $("div.third").replaceWith($(".first")); // 戻り値 $("div.third")
  </script>
  
  操作後
  <div class="container">
    <div class="inner second">次郎</div>
    <div class="inner first">太郎</div>
  </div>

  <!-- 例 replaceWith()-3 -->
  <script>
    $("div.inner").replaceWith("<h2>花子</h2>");
  </script>
  
  操作後
  <div class="container">
    <h2>花子</h2>
    <h2>花子</h2>
    <h2>花子</h2>
  </div>

  <h2>削除, クローン</h2>
  remove()  要素そのものを削除 戻り値はレシーバオブジェクト(つまり普通)
  empty()   要素の内側を削除

  clone()   コピーを作成して返す
    参照じゃないのでこれをappendしても元のオブジェクトに影響しないということ
    idの重複に注意

  <h2>Traversing(横断) ノードウォーキング的な</h2>
  first()
  last()
  eq(n)        0始まり 負の値を指定した場合は後ろから数える
  filter(slct)    絞り込み
  not(slct)
  find(slct)      要素の子孫要素から探せる

  prev(slct)
  prevAll(slct)
  next(slct)
  nextAll(slct)
  parent(slct)
  parents(slct)
  children(slct)  子すべて
  siblings(slct)  兄弟全て
  closet(slct)    選択した各要素のslctにマッチする最も近い先祖要素を選択(？)

  end(slct)       要素の横断を一つ戻る ひとつ前の選択状態に戻る スタックのイメージ
  addBack(slct)   要素の横断を一つ進む(？)

  <h2>jQueryオブジェクト操作</h2>
  length                    選択中の要素数
  each(function(idx, elm))  foreach elmはthis return false;がきく
  get(n)                    [n]と同じ
  toArray()
  map(function(idx, elm))   普通にmap
  index()                   index(), index(elm), index(slct) 複数の場合は最初の要素の位置

  <h2>イベント</h2>
  on( events[, slct][, data], handler)
  on( events-map[, slct][, data])

  events      スペース区切りで複数指定可能 "mouseenter mouseleave"
  slct        イベントの委譲を行える $("ul").on(event, "li", handler)
  data        ハンドラを使いまわしても要素ごとに渡すデータを選択でき、処理を分岐できる
              文字列単体で渡すときは、slctとみなされないようにslct部分にnullを渡す必要あり
  events-map  オブジェクトとして複数のイベント+ハンドラをまとめて指定する

  <script>
    $("#click_me").on("click", function() {
      alert("クリックされました");
    });
    $("ul").on("click", "li", function() {
      alert($(this).text());
    });
    // HTMLにdata-nameとかつけておく方法もあり
    $("#taro").on("click", {name: "太郎", area: "東京"}, greet);
    $("#jiro").on("click", {name: "次郎", area: "埼玉"}, greet);
    function greet(event) {
      alert(event.data.area + "の" + event.data.name + "です。");
    };
    $("#view").on({
      mouseenter: function() {
        // 処理;
      },
      mouseleave: function() {
        // 処理;
      }
    });
  </script>

  <h3>イベント委譲</h3>
  子要素全部にイベントをつけていたら要素の増減などに対応しきれないので、親要素にイベントをつけて処理のときにどの子要素が発生源となったかを確認して実行する

  <h3>イベント付与のショートカット</h3>
  通常はon("",func)使えだが、ショートカットが用意されているものもある
  ready()  いつも書くやつ。これについては逆にon()での指定がv3.0で廃止
  blur change click dblclick error(v3.0で廃止)
  focus focusin focusout keydown keypress keyup
  load mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup
  resize scroll select submit unload(v3.0で廃止)

  <h3>イベントのthisについて</h3>
  thisはvanillaと同じなので、jQueryで使用するときは$(this)の形になることが多い

  <h3>hover</h3>
  オブジェクト.hover(func1, func2)  ホバーイベント用のjQueryオブジェクトメソッド
  <script>
    $("#menu").hover(function() {
      $(this).css("color", "blue");
    }, function() {
      $(this).css("color", "red");
    })
  </script>

  <h3>その他メソッド</h3>
  one()             イベントを付与するが各要素につき一回だけでイベントリスナーが解除される
  off()             イベントリスナーの解除(引数指定で絞り込み)
    off(events[, slct][, handler(eventObject)])
    off(events-map[, slct])
  trigger()         発火 設定してある要素の全てが動作 戻り値はjQueryオブジェクト
  triggerHandler()  発火 設定してある要素の一つ目のみ動作 戻り値はハンドラのreturn
                    バブリングなし デフォルト動作

  <h3>オリジナルの名前でイベントを設定する</h3>
  trigger()で発火することを前提に、標準にはないイベント("myevent"など)を指定してもよい
  それをclickイベントのハンドラ内で発火するのもよい(うざくない？いい？)
  offやtriggerでの管理が楽になるかも

  <h3>読み込みが画像まで終了してから実行</h3>
  <script>
    $(window).on("load", function() {
      // 読み込み後の処理;
    });
  </script>

</body>
</html>